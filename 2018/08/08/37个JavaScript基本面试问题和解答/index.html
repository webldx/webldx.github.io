<!DOCTYPE html>
<html >

        <head>
            
    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

                <meta charset="utf-8">
                <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
                <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
                <meta name="format-detection" content="telephone=no" />
                <meta name="author" content="李大玄" />

                

                                        <meta name="description" content="37个JavaScript基本面试问题和解答">
<meta name="keywords" content="37个JavaScript基本面试问题和解答">
<meta property="og:type" content="article">
<meta property="og:title" content="37个JavaScript基本面试问题和解答">
<meta property="og:url" content="http://yoursite.com/2018/08/08/37个JavaScript基本面试问题和解答/index.html">
<meta property="og:site_name" content="李大玄的博客">
<meta property="og:description" content="37个JavaScript基本面试问题和解答">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-08-09T08:30:35.334Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="37个JavaScript基本面试问题和解答">
<meta name="twitter:description" content="37个JavaScript基本面试问题和解答">

                                            <link rel="apple-touch-icon" href="/apple-touch-icon.png">

                                            
                                                <link rel="alternate" href="/atom.xml" title="李大玄的博客" type="application/atom+xml">
                                                

                                                    
                                                        <link rel="shortcut icon" href="/img/favicon.ICO">
                                                        

                                                            
                                                                <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">
                                                                

                                                                    
                                                                        <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
                                                                        

                                                                            
                                                                                <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
                                                                                <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
                                                                                

                                                                                    <link rel="stylesheet" href="/css/style.css">

                                                                                        

                                                                                                <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">

                                                                                                
                                                                                                    <title>
                                                                                                        
                                                                                                            37个JavaScript基本面试问题和解答 |
                                                                                                                
                                                                                                                    李大玄的博客
                                                                                                    </title>

                                                                                                    <script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
                                                                                                    <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

                                                                                                    <script>
                                                                                                        var yiliaConfig = {
                                                                                                            fancybox: true,
                                                                                                            animate: true,
                                                                                                            isHome: false,
                                                                                                            isPost: true,
                                                                                                            isArchive: false,
                                                                                                            isTag: false,
                                                                                                            isCategory: false,
                                                                                                            fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
                                                                                                            scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
                                                                                                            search: false
                                                                                                        }
                                                                                                    </script>

                                                                                                    
                                                                                                            <script>
                                                                                                                yiliaConfig.jquery_ui = [false];
                                                                                                            </script>
                                                                                                            

                                                                                                                
                                                                                                                        <script>
                                                                                                                            yiliaConfig.rootUrl = "\/";
                                                                                                                        </script>
                                                                                                                        

                                                                                                                            

                                                                                                                                    

        </head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/346017689849280708.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">李大玄</a></h1>
        </hgroup>

        
        <p class="header-subtitle">我从不幻想,我只是在努力认清现实!</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/get方法封装步骤/">$.get方法封装步骤</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/2018年web前端经典面试题及答案/">2018年web前端经典面试题及答案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/37个JavaScript基本面试问题和解答/">37个JavaScript基本面试问题和解答</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/3D切割轮播图-思路分析-代码实现/">3D切割轮播图 思路分析 代码实现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-6-let和const命令/">ECMAScript 6 let和const命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSONP的优缺点/">JSONP的优缺点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP中session与cookie的区别/">JSP中session与cookie的区别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS中this关键字详解/">JS中this关键字详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript垃圾回收机制/">JavaScript垃圾回收机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NaN的定义与用法/">NaN的定义与用法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css清除浮动-四种方式/">css清除浮动, 四种方式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html常见的兼容性问题？/">html常见的兼容性问题？</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript中filter的用法/">javascript中filter的用法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js基础-、js介绍-、变量、-数据类型-、-分支结构/">js基础 、js介绍 、变量、 数据类型 、 分支结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown基本语法/">markdown基本语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全选-反选-不选/">全选  反选  不选</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/公式/">公式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数的创建-函数本身-函数中的this指向-函数的其它成员/">函数的创建 函数本身 函数中的this指向 函数的其它成员</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分析轮播图每一步进行操作/">分析轮播图每一步进行操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端面试题整理/">前端面试题整理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区别-引用/">区别 引用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原型继承-借用构造函数-组合继承/">原型继承 借用构造函数 组合继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串的操作/">字符串的操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对于页面适配，你应该使用px还是rem-em-rem-px/">对于页面适配，你应该使用px还是rem em rem px</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/封装移动端手势事件-touchstart-touchmove-touchend/">封装移动端手势事件 touchstart touchmove touchend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搭建GitHub步骤/">搭建GitHub步骤</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组去重的几种方法/">数组去重的几种方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组的方法/">数组的方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/根据分析-进行样式/">根据分析,进行样式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/根据用户需求分析-思路-步骤/">根据用户需求分析 思路 步骤</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板/">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端轮播图-移动端三大事件/">移动端轮播图 移动端三大事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/精灵图的优缺点/">精灵图的优缺点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求-服务器代理-cors-跨域资源共享-jsonp/">跨域请求 服务器代理  cors(跨域资源共享) jsonp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/闭包-执行栈-执行队列/">闭包  执行栈 执行队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/雪花飘落/">雪花飘落</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">李大玄</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/346017689849280708.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">李大玄</a></h1>
            </hgroup>
            
            <p class="header-subtitle">我从不幻想,我只是在努力认清现实!</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-37个JavaScript基本面试问题和解答" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/08/37个JavaScript基本面试问题和解答/" class="article-date">
      <time datetime="2018-08-08T08:39:05.587Z" itemprop="datePublished">2018-08-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      37个JavaScript基本面试问题和解答
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/37个JavaScript基本面试问题和解答/">37个JavaScript基本面试问题和解答</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="1、使用typeof-bar-“object”来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免？"><a href="#1、使用typeof-bar-“object”来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免？" class="headerlink" title="1、使用typeof bar ===“object”来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免？"></a><strong>1、使用typeof bar ===“object”来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免？</strong></h3><p>尽管typeof bar ===“object”是检查bar是否是对象的可靠方法，但JavaScript中令人惊讶的问题是<em>null</em>也被认为是一个对象！</p>
<p>因此，对于大多数开发人员来说，下面的代码会将真实（而不是错误）记录到控制台：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; var bar = null;</span><br><span class="line">&gt; console.log(typeof bar === &quot;object&quot;);</span><br><span class="line">&gt;   // logs true!</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>只要知道这一点，就可以通过检查bar是否为空来轻松避免该问题：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;)); </span><br><span class="line">&gt;  // logs false</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为了在我们的答案更加的完整，还有两件事值得注意：</p>
<p>首先，如果bar是一个函数，上面的解决方案将返回false。在大多数情况下，这是所期望的行为，但是在您希望函数返回true的情况下，您可以将上述解决方案修改为：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log((bar !== null) &amp;&amp; ((typeof bar === &quot;object&quot;) || (typeof bar === &quot;function&quot;)));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其次，如果bar是数组，则上述解决方案将返回true（例如，如果var bar = [];）。在大多数情况下，这是所希望的行为，因为数组确实是对象，但是在您想要对数组也是false的情况下，可以将上述解决方案修改为：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;) &amp;&amp; (toString.call(bar) !== &quot;[object Array]&quot;));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是，还有一个替代方法对空值，数组和函数返回false，但对于对象则为true：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log((bar !== null) &amp;&amp; (bar.constructor === Object));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>或者，如果您使用jQuery：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;) &amp;&amp; (! $.isArray(bar)));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>ES5使得数组的情况非常简单，包括它自己的空检查：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(Array.isArray(bar));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="2、下面的代码将输出到控制台的是什么，为什么？"><a href="#2、下面的代码将输出到控制台的是什么，为什么？" class="headerlink" title="2、下面的代码将输出到控制台的是什么，为什么？"></a><strong>2、下面的代码将输出到控制台的是什么，为什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; (function()&#123;</span><br><span class="line">&gt;   var a = b = 3;</span><br><span class="line">&gt; &#125;)();</span><br><span class="line">&gt;   console.log(&quot;a defined? &quot; + (typeof a !== &apos;undefined&apos;));</span><br><span class="line">&gt;   console.log(&quot;b defined? &quot; + (typeof b !== &apos;undefined&apos;));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由于a和b都在函数的封闭范围内定义，并且由于它们所在的行以var关键字开头，因此大多数JavaScript开发人员会希望typeof a和typeof b在上面的示例中都未定义。</p>
<p>但是，情况并非如此。这里的问题是大多数开发人员错误地理解语句var a = b = 3;以下简写为：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var b = 3;var a = b;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但实际上，var a = b = 3;其实是速记：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; b = 3;var a = b;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此（如果您不使用严格模式），代码片段的输出将为：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; a defined? falseb defined? true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是如何在封闭函数的范围之外定义b？那么，因为声明var a = b = 3;是语句b = 3的简写;并且var a = b; b最终成为一个全局变量（因为它不在var关键字后面），因此它仍然在作用域内，即使在封闭函数之外。</p>
<p>注意，在严格模式下（即，使用strict），语句var a = b = 3;会产生一个ReferenceError的运行时错误：b没有定义，从而避免了可能导致的任何头headfakes/bugs。 （这就是为什么你应该在你的代码中使用strict，一个重要的例子！）</p>
<h3 id="3、下面的代码将输出到控制台的是什么？，为什么？"><a href="#3、下面的代码将输出到控制台的是什么？，为什么？" class="headerlink" title="3、下面的代码将输出到控制台的是什么？，为什么？"></a><strong>3、下面的代码将输出到控制台的是什么？，为什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; var myObject = &#123;    </span><br><span class="line">&gt; foo: &quot;bar&quot;,   </span><br><span class="line">&gt; func: function() &#123; </span><br><span class="line">&gt;        var self = this;        </span><br><span class="line">&gt;        console.log(&quot;outer func:  this.foo = &quot; + this.foo);     </span><br><span class="line">&gt;           console.log(&quot;outer func:  self.foo = &quot; + self.foo);</span><br><span class="line">&gt;         (function() &#123;          </span><br><span class="line">&gt;             console.log(&quot;inner func:  this.foo = &quot; + this.foo);     </span><br><span class="line">&gt;             console.log(&quot;inner func:  self.foo = &quot; + self.foo);</span><br><span class="line">&gt;         &#125;());</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; myObject.func();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以上代码将输出到控制台：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; outer func:  this.foo = barouter func:  </span><br><span class="line">&gt; self.foo = barinner func:  </span><br><span class="line">&gt; this.foo = undefinedinner func: </span><br><span class="line">&gt;  self.foo = bar</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在外部函数中，this和self都引用myObject，因此都可以正确地引用和访问foo。</p>
<p>但在内部函数中，这不再指向myObject。因此，this.foo在内部函数中是未定义的，而对局部变量self的引用仍然在范围内并且可以在那里访问。</p>
<h3 id="4、在功能块中封装JavaScript源文件的全部内容的重要性和原因是什么？"><a href="#4、在功能块中封装JavaScript源文件的全部内容的重要性和原因是什么？" class="headerlink" title="4、在功能块中封装JavaScript源文件的全部内容的重要性和原因是什么？"></a><strong>4、在功能块中封装JavaScript源文件的全部内容的重要性和原因是什么？</strong></h3><p>这是一种日益普遍的做法，被许多流行的JavaScript库（jQuery，Node.js等）所采用。这种技术在文件的全部内容周围创建一个闭包，这可能最重要的是创建一个私有名称空间，从而有助于避免不同JavaScript模块和库之间的潜在名称冲突。</p>
<p>这种技术的另一个特点是为全局变量提供一个容易引用（可能更短）的别名。例如，这通常用于jQuery插件。 </p>
<p>jQuery允许您使用jQuery.noConflict（）来禁用对jQuery名称空间的$引用。如果这样做了，你的代码仍然可以使用$使用闭包技术，如下所示：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; (function($) &#123;</span><br><span class="line">&gt;  /* jQuery plugin code referencing $ */ </span><br><span class="line">&gt;  &#125; )</span><br><span class="line">&gt; (jQuery);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="5、在JavaScript源文件的开头包含’use-strict’的意义和有什么好处？"><a href="#5、在JavaScript源文件的开头包含’use-strict’的意义和有什么好处？" class="headerlink" title="5、在JavaScript源文件的开头包含’use strict’的意义和有什么好处？"></a><strong>5、在JavaScript源文件的开头包含’use strict’的意义和有什么好处？</strong></h3><p>这里最简单也是最重要的答案是use strict是<em>一种在运行时自动执行更严格的JavaScript代码解析和错误处理的方法</em>。</p>
<p>如果代码错误被忽略或失败，将会产生错误或抛出异常。总的来说，这是一个很好的做法。</p>
<p>严格模式的一些主要优点包括：</p>
<ul>
<li><p>使调试更容易。 如果代码错误本来会被忽略或失败，那么现在将会产生错误或抛出异常，从而更快地发现代码中的问题，并更快地指引它们的源代码。</p>
</li>
<li><p>防止意外全局。 如果没有严格模式，将值赋给未声明的变量会自动创建一个具有该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，尝试这样做会引发错误。</p>
</li>
<li><p>消除隐藏威胁。在没有严格模式的情况下，对null或undefined的这个值的引用会自动强制到全局。这可能会导致许多<em>headfakes</em>和<em>pull-out-your-hair</em>类型的错误。在严格模式下，引用null或undefined的这个值会引发错误。</p>
</li>
<li><p>不允许重复的参数值。 严格模式在检测到函数的重复命名参数（例如，函数foo（val1，val2，val1）{}）时会引发错误，从而捕获代码中几乎可以肯定存在的错误，否则您可能会浪费大量的时间追踪。</p>
</li>
<li><ul>
<li>注意：它曾经是（在ECMAScript 5中）strict模式将禁止重复的属性名称（例如var object = {foo：“bar”，foo：“baz”};）但是从ECMAScript 2015 开始，就不再有这种情况了。</li>
</ul>
</li>
<li><p>使eval（）更安全。 eval（）在严格模式和非严格模式下的行为方式有些不同。最重要的是，在严格模式下，在eval（）语句内部声明的变量和函数不会在包含范围中创建（它们是以非严格模式在包含范围中创建的，这也可能是问题的常见来源）。</p>
</li>
<li><p>抛出无效的使用错误的删除符。 删除操作符（用于从对象中删除属性）不能用于对象的不可配置属性。当试图删除一个不可配置的属性时，非严格代码将自动失败，而在这种情况下，严格模式会引发错误。</p>
</li>
</ul>
<h3 id="6、考虑下面的两个函数。他们都会返回同样的值吗？为什么或者为什么不？"><a href="#6、考虑下面的两个函数。他们都会返回同样的值吗？为什么或者为什么不？" class="headerlink" title="6、考虑下面的两个函数。他们都会返回同样的值吗？为什么或者为什么不？"></a><strong>6、考虑下面的两个函数。他们都会返回同样的值吗？为什么或者为什么不？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; function foo1()</span><br><span class="line">&gt; &#123;  return &#123;</span><br><span class="line">&gt;       bar: &quot;hello&quot;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; &#125;function foo2()</span><br><span class="line">&gt; &#123;  return</span><br><span class="line">&gt;   &#123;</span><br><span class="line">&gt;       bar: &quot;hello&quot;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>令人惊讶的是，这两个函数不会返回相同的结果。而是：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(&quot;foo1 returns:&quot;);</span><br><span class="line">&gt; console.log(foo1());</span><br><span class="line">&gt; console.log(&quot;foo2 returns:&quot;);</span><br><span class="line">&gt; console.log(foo2());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>会产生：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; foo1 returns:Object &#123;bar: &quot;hello&quot;&#125;foo2 returns:undefined</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这不仅令人惊讶，而且特别令人烦恼的是，foo2（）返回未定义而没有引发任何错误。</p>
<p>原因与JavaScript中分号在技术上是可选的事实有关（尽管忽略它们通常是非常糟糕的形式）。因此，在foo2（）中遇到包含return语句的行（没有其他内容）时，<em>会在return语句之后立即自动插入分号。</em></p>
<p>由于代码的其余部分是完全有效的，即使它没有被调用或做任何事情（它只是一个未使用的代码块，它定义了一个属性栏，它等于字符串“hello”），所以不会抛出任何错误。</p>
<p>这种行为也被认为是遵循了在JavaScript中将一行开头大括号放在行尾的约定，而不是在新行的开头。如此处所示，这不仅仅是JavaScript中的一种风格偏好。</p>
<p>### </p>
<h3 id="7、什么是NaN？它的类型是什么？如何可靠地测试一个值是否等于NaN？"><a href="#7、什么是NaN？它的类型是什么？如何可靠地测试一个值是否等于NaN？" class="headerlink" title="7、什么是NaN？它的类型是什么？如何可靠地测试一个值是否等于NaN？"></a><strong>7、什么是NaN？它的类型是什么？如何可靠地测试一个值是否等于NaN？</strong></h3><p>NaN属性表示“不是数字”的值。这个特殊值是由于一个操作数是非数字的（例如“abc”/ 4）或者因为操作的结果是非数字而无法执行的。</p>
<p>虽然这看起来很简单，但NaN有一些令人惊讶的特征，如果人们没有意识到这些特征，就会导致bug。</p>
<p>一方面，虽然NaN的意思是“不是数字”，但它的类型是，数字：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(typeof NaN === &quot;number&quot;);  </span><br><span class="line">&gt; // logs &quot;true&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此外，NaN相比任何事情 - 甚至本身！ - 是false：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(NaN === NaN);</span><br><span class="line">&gt;   // logs &quot;false&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>测试数字是否等于NaN的半可靠方法是使用内置函数isNaN（），但即使使用isNaN（）也不是一个好的解决方案。.</p>
<p>一个更好的解决方案要么是使用value！==值，如果该值等于NaN，那么只会生成true。另外，ES6提供了一个新的Number.isNaN（）函数 ，它与旧的全局isNaN（）函数不同，也更加可靠。</p>
<h3 id="8、下面的代码输出什么？解释你的答案。"><a href="#8、下面的代码输出什么？解释你的答案。" class="headerlink" title="8、下面的代码输出什么？解释你的答案。"></a><strong>8、下面的代码输出什么？解释你的答案。</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(0.1 + 0.2);</span><br><span class="line">&gt; console.log(0.1 + 0.2 == 0.3);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对这个问题的一个有教养的回答是：“你不能确定。它可能打印出0.3和true，或者可能不打印。 JavaScript中的数字全部用浮点精度处理，因此可能不会总是产生预期的结果。“</p>
<p>上面提供的示例是演示此问题的经典案例。令人惊讶的是，它会打印出来：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0.30000000000000004false</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一个典型的解决方案是比较两个数字与特殊常数Number.EPSILON之间的绝对差值：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; function areTheNumbersAlmostEqual(num1, num2) &#123; </span><br><span class="line">&gt;    return Math.abs( num1 - num2 ) &lt; Number.EPSILON;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; console.log(areTheNumbersAlmostEqual(0.1 + 0.2, 0.3));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>讨论写函数的可能方法isInteger（x），它确定x是否是一个整数。</p>
<p>这听起来很平凡，事实上，ECMAscript 6为此正好引入了一个新的Number.isInteger（）函数，这是微不足道的。但是，在ECMAScript 6之前，这有点复杂，因为没有提供与Number.isInteger（）方法等价的方法。</p>
<p>问题在于，在ECMAScript规范中，整数只在概念上存在;即数值始终作为浮点值存储。</p>
<p>考虑到这一点，最简单，最清洁的ECMAScript-6之前的解决方案（即使将非数字值（例如字符串或空值）传递给该函数，该解决方案也具有足够的可靠性以返回false）将成为以下用法按位异或运算符：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; function isInteger(x) &#123; return (x ^ 0) === x; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面的解决方案也可以工作，尽管不如上面那样高雅</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; function isInteger(x) &#123; return Math.round(x) === x; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>请注意，在上面的实现中Math.ceil（）或Math.floor（）可以同样使用（而不是Math.round（））。</p>
<p>或者：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; function isInteger(x) &#123;</span><br><span class="line">&gt;  return (typeof x === &apos;number&apos;) &amp;&amp; (x % 1 === 0); </span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一个相当常见的不正确的解决方案如下：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; function isInteger(x) &#123; </span><br><span class="line">&gt; return parseInt(x, 10) === x; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>虽然这个基于parseInt的方法对许多x值很有效，但一旦x变得相当大，它将无法正常工作。问题是parseInt（）在解析数字之前将其第一个参数强制转换为字符串。因此，一旦数字变得足够大，其字符串表示将以指数形式呈现（例如1e + 21）。因此，parseInt（）将尝试解析1e + 21，但是当它到达e字符时将停止解析，因此将返回值1.观察：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; String(1000000000000000000000)&apos;1e+21&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; parseInt(1000000000000000000000, 10)1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; parseInt(1000000000000000000000, 10) === 1000000000000000000000false</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="9、执行下面的代码时，按什么顺序将数字1-4记录到控制台？为什么？"><a href="#9、执行下面的代码时，按什么顺序将数字1-4记录到控制台？为什么？" class="headerlink" title="9、执行下面的代码时，按什么顺序将数字1-4记录到控制台？为什么？"></a>9、执行下面的代码时，按什么顺序将数字1-4记录到控制台？为什么？</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; (function() &#123;</span><br><span class="line">&gt;     console.log(1); </span><br><span class="line">&gt;     setTimeout(function()&#123;console.log(2)&#125;, 1000); </span><br><span class="line">&gt;     setTimeout(function()&#123;console.log(3)&#125;, 0); </span><br><span class="line">&gt;     console.log(4);&#125;)();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这些值将按以下顺序记录：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1432</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们先来解释一下这些可能更为明显的部分：</p>
<ul>
<li>首先显示1和4，因为它们是通过简单调用console.log（）而没有任何延迟记录的</li>
<li>在3之后显示，因为在延迟1000毫秒（即1秒）之后记录2，而在0毫秒的延迟之后记录3。</li>
</ul>
<p>好的。但是，如果在延迟0毫秒后记录3，这是否意味着它正在被立即记录？而且，如果是这样，不应该在4之前记录它，因为4是由后面的代码行记录的吗？</p>
<p>答案与正确理解JavaScript事件和时间有关。 .</p>
<p>浏览器有一个事件循环，它检查事件队列并处理未决事件。例如，如果在浏览器繁忙时（例如，处理onclick）在后台发生事件（例如脚本onload事件），则该事件被附加到队列中。当onclick处理程序完成时，将检查队列并处理该事件（例如，执行onload脚本）。</p>
<p>同样，如果浏览器繁忙，setTimeout（）也会将其引用函数的执行放入事件队列中。</p>
<p>当值为零作为setTimeout（）的第二个参数传递时，它将尝试“尽快”执行指定的函数。具体来说，函数的执行放置在事件队列中，以在下一个计时器滴答时发生。但请注意，这不是直接的;该功能不会执行，直到下一个滴答声。这就是为什么在上面的例子中，调用console.log（4）发生在调用console.log（3）之前（因为调用console.log（3）是通过setTimeout调用的，所以稍微延迟了一点）。</p>
<h3 id="10、编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是-palindrome-。"><a href="#10、编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是-palindrome-。" class="headerlink" title="10、编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是**palindrome**。"></a><strong>10、编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是**</strong>palindrome<strong>**。</strong></h3><p>如果str是回文，以下一行函数将返回true;否则，它返回false。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; function isPalindrome(str) &#123;  </span><br><span class="line">&gt; str = str.replace(/\W/g, &apos;&apos;).toLowerCase();  </span><br><span class="line">&gt; return (str == str.split(&apos;&apos;).reverse().join(&apos;&apos;));</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>例如：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(isPalindrome(&quot;level&quot;));                  </span><br><span class="line">&gt;  // logs &apos;true&apos;console.log(isPalindrome(&quot;levels&quot;));        </span><br><span class="line">&gt;            // logs &apos;false&apos;</span><br><span class="line">&gt; console.log(isPalindrome(&quot;A car, a man, a maraca&quot;)); </span><br><span class="line">&gt;             // logs &apos;true&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="11、写一个sum方法，当使用下面的语法调用时它将正常工作。"><a href="#11、写一个sum方法，当使用下面的语法调用时它将正常工作。" class="headerlink" title="11、写一个sum方法，当使用下面的语法调用时它将正常工作。"></a><strong>11、写一个sum方法，当使用下面的语法调用时它将正常工作。</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(sum(2,3));   </span><br><span class="line">&gt; // Outputs 5</span><br><span class="line">&gt; console.log(sum(2)(3)); </span><br><span class="line">&gt;  // Outputs 5</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>有（至少）两种方法可以做到这一点：</p>
<p>METHOD 1</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; function sum(x) &#123;  if (arguments.length == 2) &#123;    </span><br><span class="line">&gt; return arguments[0] + arguments[1];</span><br><span class="line">&gt;   &#125; else &#123;  </span><br><span class="line">&gt;   return function(y) &#123; return x + y; &#125;;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在JavaScript中，函数提供对参数对象的访问，该对象提供对传递给函数的实际参数的访问。这使我们能够使用length属性在运行时确定传递给函数的参数的数量</p>
<p>如果传递两个参数，我们只需将它们相加并返回。</p>
<p>否则，我们假设它是以sum（2）（3）的形式被调用的，所以我们返回一个匿名函数，它将传递给sum（）（在本例中为2）的参数和传递给匿名函数的参数这种情况3）。</p>
<p>METHOD 2</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; function sum(x, y) &#123;  </span><br><span class="line">&gt; if (y !== undefined) &#123;</span><br><span class="line">&gt;     return x + y;</span><br><span class="line">&gt;   &#125; else &#123;    </span><br><span class="line">&gt;     return function(y) &#123; return x + y; &#125;;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当函数被调用时，JavaScript不需要参数的数量来匹配函数定义中参数的数量。如果传递的参数数量超过了函数定义中参数的数量，则超出的参数将被忽略。另一方面，如果传递的参数数量少于函数定义中的参数数量，则在函数内引用时，缺少的参数将具有未定义的值。因此，在上面的例子中，通过简单地检查第二个参数是否未定义，我们可以确定函数被调用的方式并相应地继续。</p>
<h3 id="12、考虑下面的代码片段"><a href="#12、考虑下面的代码片段" class="headerlink" title="12、考虑下面的代码片段"></a><strong>12、考虑下面的代码片段</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">&gt;   var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">&gt;   btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">&gt;   btn.addEventListener(&apos;click&apos;, function()&#123; console.log(i); &#125;); </span><br><span class="line">&gt;    document.body.appendChild(btn);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>(a) 当用户点击“按钮4”时，什么被记录到控制台？为什么？</p>
<p>(b) 提供一个或多个可按预期工作的替代实现。</p>
<p>答：</p>
<p>(a) 无论用户点击哪个按钮，数字5将始终记录到控制台。这是因为，在调用onclick方法（对于任何按钮）时，for循环已经完成，并且变量i已经具有值5.（如果受访者知道足够的话就可以获得奖励点数关于执行上下文，变量对象，激活对象和内部“范围”属性如何影响闭包行为。）</p>
<p>(b) 使这项工作的关键是通过将它传递给新创建的函数对象来捕获每次通过for循环的i的值。以下是四种可能的方法来实现这一点：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">&gt;   var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">&gt;   btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">&gt;   btn.addEventListener(&apos;click&apos;, (function(i) &#123;</span><br><span class="line">&gt;     return function() &#123; console.log(i); &#125;;</span><br><span class="line">&gt;   &#125;)(i));</span><br><span class="line">&gt;   document.body.appendChild(btn);&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>或者，您可以将新的匿名函数中的整个调用包装为btn.addEventListener：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">&gt;   var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">&gt;   btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">&gt;   (function (i) &#123;</span><br><span class="line">&gt;     btn.addEventListener(&apos;click&apos;, function() &#123; console.log(i); &#125;);</span><br><span class="line">&gt;   &#125;)(i);</span><br><span class="line">&gt;   document.body.appendChild(btn);&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>或者，我们可以通过调用数组对象的原生forEach方法来替换for循环：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;].forEach(function (value, i) &#123; </span><br><span class="line">&gt;  var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">&gt;   btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">&gt;   btn.addEventListener(&apos;click&apos;, function() &#123; console.log(i); &#125;);</span><br><span class="line">&gt;    document.body.appendChild(btn);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后，最简单的解决方案，如果你在ES6 / ES2015上下文中，就是使用let i而不是var i：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (let i = 0; i &lt; 5; i++) &#123;  </span><br><span class="line">&gt; var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">&gt;   btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">&gt;   btn.addEventListener(&apos;click&apos;, function()&#123; console.log(i); &#125;);</span><br><span class="line">&gt;   document.body.appendChild(btn);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="13、假设d是范围内的“空”对象："><a href="#13、假设d是范围内的“空”对象：" class="headerlink" title="13、假设d是范围内的“空”对象："></a><strong>13、假设d是范围内的“空”对象：</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var d = &#123;&#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>…使用下面的代码完成了什么？</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ &apos;zebra&apos;, &apos;horse&apos; ].forEach(function(k) &#123;</span><br><span class="line">&gt;     d[k] = undefined;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面显示的代码片段在对象d上设置了两个属性。理想情况下，对具有未设置键的JavaScript对象执行的查找评估为未定义。但是运行这段代码会将这些属性标记为对象的“自己的属性”。</p>
<p>这是确保对象具有一组给定属性的有用策略。将该对象传递给Object.keys将返回一个包含这些设置键的数组（即使它们的值未定义）。</p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="14、下面的代码将输出到控制台，为什么？"><a href="#14、下面的代码将输出到控制台，为什么？" class="headerlink" title="14、下面的代码将输出到控制台，为什么？"></a><strong>14、下面的代码将输出到控制台，为什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; var arr1 = &quot;john&quot;.split(&apos;&apos;);</span><br><span class="line">&gt; var arr2 = arr1.reverse();</span><br><span class="line">&gt; var arr3 = &quot;jones&quot;.split(&apos;&apos;);</span><br><span class="line">&gt; arr2.push(arr3);</span><br><span class="line">&gt; console.log(&quot;array 1: length=&quot; + arr1.length + &quot; last=&quot; + arr1.slice(-1));</span><br><span class="line">&gt; console.log(&quot;array 2: length=&quot; + arr2.length + &quot; last=&quot; + arr2.slice(-1));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>记录的输出将是：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &quot;array 1: length=5 last=j,o,n,e,s&quot;&quot;array 2: length=5 last=j,o,n,e,s&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>arr1和arr2是相同的（即[‘n’，’h’，’o’，’j’，[‘j’，’o’，’n’，’e’，’s’]]）上述代码由于以下原因而被执行：</p>
<ul>
<li>调用数组对象的reverse（）方法不仅以相反的顺序返回数组，它还颠倒了数组本身的顺序（即在这种情况下，arr1）。</li>
<li>reverse（）方法返回对数组本身的引用（即，在这种情况下为arr1）。因此，arr2仅仅是对arr1的引用（而不是副本）。因此，当对arr2做任何事情时（即，当我们调用arr2.push（arr3）;）时，arr1也会受到影响，因为arr1和arr2只是对同一个对象的引用。</li>
</ul>
<p>这里有几个观点可以让人们回答这个问题：</p>
<ul>
<li>将数组传递给另一个数组的push（）方法会将整个数组作为单个元素推入数组的末尾。结果，声明arr2.push（arr3）;将arr3作为一个整体添加到arr2的末尾（即，它不连接两个数组，这就是concat（）方法的用途）。</li>
<li>像Python一样，JavaScript在调用像slice（）这样的数组方法时，会承认负面下标，以此作为在数组末尾引用元素的方式;例如，下标-1表示数组中的最后一个元素，依此类推。</li>
</ul>
<p>### </p>
<h3 id="15、下面的代码将输出到控制台，为什么？"><a href="#15、下面的代码将输出到控制台，为什么？" class="headerlink" title="15、下面的代码将输出到控制台，为什么？"></a><strong>15、下面的代码将输出到控制台，为什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(1 +  &quot;2&quot; + &quot;2&quot;);</span><br><span class="line">&gt; console.log(1 +  +&quot;2&quot; + &quot;2&quot;);</span><br><span class="line">&gt; console.log(1 +  -&quot;1&quot; + &quot;2&quot;);</span><br><span class="line">&gt; console.log(+&quot;1&quot; +  &quot;1&quot; + &quot;2&quot;);</span><br><span class="line">&gt; console.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;);</span><br><span class="line">&gt; console.log( &quot;A&quot; - &quot;B&quot; + 2);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以上代码将输出到控制台：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &quot;122&quot;&quot;32&quot;&quot;02&quot;&quot;112&quot;&quot;NaN2&quot;NaN</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这是为什么…</p>
<p>这里的基本问题是JavaScript（ECMAScript）是一种松散类型的语言，它对值执行自动类型转换以适应正在执行的操作。让我们来看看这是如何与上面的每个例子进行比较。</p>
<p>示例1：1 +“2”+“2”输出：“122”说明：第一个操作在1 +“2”中执行。由于其中一个操作数（“2”）是一个字符串，所以JavaScript假定需要执行字符串连接，因此将1的类型转换为“1”，1 +“2”转换为“12”。然后，“12”+“2”产生“122”。</p>
<p>示例2：1 + +“2”+“2”输出：“32”说明：根据操作顺序，要执行的第一个操作是+“2”（第一个“2”之前的额外+被视为一个一元运算符）。因此，JavaScript将“2”的类型转换为数字，然后将一元+符号应用于它（即将其视为正数）。结果，下一个操作现在是1 + 2，当然这会产生3.但是，我们有一个数字和一个字符串之间的操作（即3和“2”），所以JavaScript再次转换数值赋给一个字符串并执行字符串连接，产生“32”。</p>
<p>示例3：1 + - “1”+“2”输出：“02”说明：这里的解释与前面的示例相同，只是一元运算符是 - 而不是+。因此，“1”变为1，然后在应用 - 时将其变为-1，然后将其加1到产生0，然后转换为字符串并与最终的“2”操作数连接，产生“02”。</p>
<p>示例4：+“1”+“1”+“2”输出：“112”说明：尽管第一个“1”操作数是基于其前面的一元+运算符的数值类型转换的，当它与第二个“1”操作数连接在一起时返回一个字符串，然后与最终的“2”操作数连接，产生字符串“112”。</p>
<p>示例5：“A” - “B”+“2”输出：“NaN2”说明：由于 - 运算符不能应用于字符串，并且既不能将“A”也不能将“B”转换为数值， “ - ”B“产生NaN，然后与字符串”2“串联产生”NaN2“。</p>
<p>例6：“A” - “B”+2输出：NaN说明：在前面的例子中，“A” - “B”产生NaN。但是任何运算符应用于NaN和其他数字操作数仍然会产生NaN。</p>
<h3 id="16、如果数组列表太大，以下递归代码将导致堆栈溢出。你如何解决这个问题，仍然保留递归模式？"><a href="#16、如果数组列表太大，以下递归代码将导致堆栈溢出。你如何解决这个问题，仍然保留递归模式？" class="headerlink" title="16、如果数组列表太大，以下递归代码将导致堆栈溢出。你如何解决这个问题，仍然保留递归模式？"></a><strong>16、如果数组列表太大，以下递归代码将导致堆栈溢出。你如何解决这个问题，仍然保留递归模式？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; var list = readHugeList();</span><br><span class="line">&gt; var nextListItem = function() &#123;    </span><br><span class="line">&gt; var item = list.pop();    if (item) &#123;      </span><br><span class="line">&gt;   // process the list item...</span><br><span class="line">&gt;         nextListItem();</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>通过修改nextListItem函数可以避免潜在的堆栈溢出，如下所示：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; var list = readHugeList();</span><br><span class="line">&gt; var nextListItem = function() &#123;   </span><br><span class="line">&gt;  var item = list.pop();    if (item) &#123;   </span><br><span class="line">&gt;       // process the list item...</span><br><span class="line">&gt;         setTimeout( nextListItem, 0);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>堆栈溢出被消除，因为事件循环处理递归，而不是调用堆栈。当nextListItem运行时，如果item不为null，则将超时函数（nextListItem）推送到事件队列，并且函数退出，从而使调用堆栈清零。当事件队列运行超时事件时，将处理下一个项目，并设置一个计时器以再次调用nextListItem。因此，该方法从头到尾不经过直接递归调用即可处理，因此调用堆栈保持清晰，无论迭代次数如何。</p>
<p>### </p>
<h3 id="17、什么是JavaScript中的“闭包”？举一个例子。"><a href="#17、什么是JavaScript中的“闭包”？举一个例子。" class="headerlink" title="17、什么是JavaScript中的“闭包”？举一个例子。"></a><strong>17、什么是JavaScript中的“闭包”？举一个例子。</strong></h3><p>闭包是一个内部函数，它可以访问外部（封闭）函数的作用域链中的变量。闭包可以访问三个范围内的变量;具体来说：（1）变量在其自己的范围内，（2）封闭函数范围内的变量，以及（3）全局变量。</p>
<p>这里是一个例子：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; var globalVar = &quot;xyz&quot;;</span><br><span class="line">&gt; (function outerFunc(outerArg) &#123;</span><br><span class="line">&gt;     var outerVar = &apos;a&apos;;</span><br><span class="line">&gt;     (function innerFunc(innerArg) &#123;</span><br><span class="line">&gt;     var innerVar = &apos;b&apos;;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     console.log(        </span><br><span class="line">&gt; &quot;outerArg = &quot; + outerArg + &quot;\n&quot; +   </span><br><span class="line">&gt;      &quot;innerArg = &quot; + innerArg + &quot;\n&quot; +   </span><br><span class="line">&gt;           &quot;outerVar = &quot; + outerVar + &quot;\n&quot; +    </span><br><span class="line">&gt;               &quot;innerVar = &quot; + innerVar + &quot;\n&quot; +     </span><br><span class="line">&gt;                  &quot;globalVar = &quot; + globalVar);</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;)(456);&#125;)(123);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在上面的例子中，innerFunc，outerFunc和全局名称空间的变量都在innerFunc的范围内。上面的代码将产生以下输出：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; outerArg = 123innerArg = 456outerVar = ainnerVar = bglobalVar = xyz</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="18、以下代码的输出是什么："><a href="#18、以下代码的输出是什么：" class="headerlink" title="18、以下代码的输出是什么："></a><strong>18、以下代码的输出是什么：</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">&gt;     setTimeout(function() &#123; </span><br><span class="line">&gt; console.log(i); &#125;, i * 1000 );</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解释你的答案。如何在这里使用闭包？</p>
<p>显示的代码示例不会显示值0,1,2,3和4，这可能是预期的;而是显示5,5,5,5。</p>
<p>这是因为循环内执行的每个函数将在整个循环完成后执行，因此所有函数都会引用存储在i中的最后一个值，即5。</p>
<p>通过为每次迭代创建一个唯一的作用域 ，可以使用闭包来防止这个问题，并将该变量的每个唯一值存储在其作用域中，如下所示：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">&gt;     (function(x) &#123;</span><br><span class="line">&gt;         setTimeout(function() </span><br><span class="line">&gt; &#123; console.log(x); &#125;, x * 1000 );</span><br><span class="line">&gt;     &#125;)(i);&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这会产生将0,1,2,3和4记录到控制台的可能结果。</p>
<p>在ES2015上下文中，您可以在原始代码中简单地使用let而不是var：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">&gt;     setTimeout(function() &#123;</span><br><span class="line">&gt;  console.log(i); &#125;, i * 1000 );</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="19、以下几行代码输出到控制台？"><a href="#19、以下几行代码输出到控制台？" class="headerlink" title="19、以下几行代码输出到控制台？"></a><strong>19、以下几行代码输出到控制台？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(&quot;0 || 1 = &quot;+(0 || 1));</span><br><span class="line">&gt; console.log(&quot;1 || 2 = &quot;+(1 || 2));</span><br><span class="line">&gt; console.log(&quot;0 &amp;&amp; 1 = &quot;+(0 &amp;&amp; 1));</span><br><span class="line">&gt; console.log(&quot;1 &amp;&amp; 2 = &quot;+(1 &amp;&amp; 2));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解释你的答案。</p>
<p>该代码将输出以下四行：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0 || 1 = 11 || 2 = 10 &amp;&amp; 1 = 01 &amp;&amp; 2 = 2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在JavaScript中，都是||和&amp;&amp;是逻辑运算符，当从左向右计算时返回第一个完全确定的“逻辑值”。</p>
<p>或（||）运算符。在形式为X || Y的表达式中，首先计算X并将其解释为布尔值。如果此布尔值为真，则返回true（1），并且不计算Y，因为“或”条件已经满足。但是，如果此布尔值为“假”，我们仍然不知道X || Y是真还是假，直到我们评估Y，并将其解释为布尔值。</p>
<p>因此，0 || 1评估为真（1），正如1 || 2。</p>
<p>和（&amp;&amp;）运算符。在X &amp;&amp; Y形式的表达式中，首先评估X并将其解释为布尔值。如果此布尔值为false，则返回false（0）并且不评估Y，因为“and”条件已失败。但是，如果这个布尔值为“真”，我们仍然不知道X &amp;&amp; Y是真还是假，直到我们评估Y，并将其解释为布尔值。</p>
<p>然而，&amp;&amp;运算符的有趣之处在于，当表达式评估为“真”时，则返回表达式本身。这很好，因为它在逻辑表达式中被视为“真”，但也可以用于在您关心时返回该值。这解释了为什么，有点令人惊讶的是，1 &amp;&amp; 2返回2（而你可能会期望它返回true或1）。</p>
<h3 id="20-、下面的代码执行时输出是什么？说明。"><a href="#20-、下面的代码执行时输出是什么？说明。" class="headerlink" title="20 、下面的代码执行时输出是什么？说明。"></a><strong>20 、下面的代码执行时输出是什么？说明。</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(false == &apos;0&apos;)</span><br><span class="line">&gt; console.log(false === &apos;0&apos;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该代码将输出：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; truefalse</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在JavaScript中，有两套相等运算符。三重相等运算符===的行为与任何传统的相等运算符相同：如果两侧的两个表达式具有相同的类型和相同的值，则计算结果为true。然而，双等号运算符在比较它们之前试图强制这些值。因此，通常使用===而不是==。对于！== vs！=也是如此。</p>
<h3 id="21、以下代码的输出是什么？解释你的答案。"><a href="#21、以下代码的输出是什么？解释你的答案。" class="headerlink" title="21、以下代码的输出是什么？解释你的答案。"></a><strong>21、以下代码的输出是什么？解释你的答案。</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; var a=&#123;&#125;,  </span><br><span class="line">&gt;  b=&#123;key:&apos;b&apos;&#125;,    </span><br><span class="line">&gt;  c=&#123;key:&apos;c&apos;&#125;;</span><br><span class="line">&gt; a[b]=123;a[c]=456;</span><br><span class="line">&gt; console.log(a[b]);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此代码的输出将是456（不是123）。</p>
<p>原因如下：设置对象属性时，JavaScript会隐式地将参数值串联起来。在这种情况下，由于b和c都是对象，它们都将被转换为“[object Object]”。因此，a [b]和a [c]都等价于[“[object Object]”]，并且可以互换使用。因此，设置或引用[c]与设置或引用[b]完全相同。</p>
<h3 id="22、以下代码将输出到控制台中"><a href="#22、以下代码将输出到控制台中" class="headerlink" title="22、以下代码将输出到控制台中."></a><strong>22、以下代码将输出到控制台中.</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log((function f(n)&#123;return ((n &gt; 1) ? n * f(n-1) : n)&#125;)(10));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该代码将输出10阶乘的值（即10！或3,628,800）。</p>
<p>原因如下：</p>
<p>命名函数f（）以递归方式调用自身，直到它调用f（1），它简单地返回1.因此，这就是它的作用：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; f(1): returns n, which is 1f(2): returns 2 * f(1), which is 2f(3): returns 3 * f(2), which is 6f(4): returns 4 * f(3), which is 24f(5): returns 5 * f(4), which is 120f(6): returns 6 * f(5), which is 720f(7): returns 7 * f(6), which is 5040f(8): returns 8 * f(7), which is 40320f(9): returns 9 * f(8), which is 362880f(10): returns 10 * f(9), which is 3628800</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="23-、考虑下面的代码片段。控制台的输出是什么，为什么？"><a href="#23-、考虑下面的代码片段。控制台的输出是什么，为什么？" class="headerlink" title="23 、考虑下面的代码片段。控制台的输出是什么，为什么？"></a><strong>23 、考虑下面的代码片段。控制台的输出是什么，为什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; (function(x) &#123;</span><br><span class="line">&gt;     return (function(y) &#123;</span><br><span class="line">&gt;         console.log(x);</span><br><span class="line">&gt;     &#125;)(2)</span><br><span class="line">&gt; &#125;)(1);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出将为1，即使x的值从未在内部函数中设置。原因如下：</p>
<p>正如我们的JavaScript招聘指南中所解释的，闭包是一个函数，以及创建闭包时在范围内的所有变量或函数。在JavaScript中，闭包被实现为“内部函数”;即在另一功能的主体内定义的功能。闭包的一个重要特征是内部函数仍然可以访问外部函数的变量。</p>
<p>因此，在这个例子中，因为x没有在内部函数中定义，所以在外部函数的作用域中搜索一个定义的变量x，该变量的值为1。</p>
<p>### </p>
<h3 id="24、以下代码将输出到控制台以及为什么"><a href="#24、以下代码将输出到控制台以及为什么" class="headerlink" title="24、以下代码将输出到控制台以及为什么"></a><strong>24、以下代码将输出到控制台以及为什么</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var hero = &#123;    </span><br><span class="line">&gt; _name: &apos;John Doe&apos;,    getSecretIdentity: function ()&#123;      </span><br><span class="line">&gt;   return this._name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;   var stoleSecretIdentity = hero.getSecretIdentity;</span><br><span class="line">&gt;   console.log(stoleSecretIdentity());</span><br><span class="line">&gt; console.log(hero.getSecretIdentity());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这段代码有什么问题，以及如何解决这个问题。</p>
<p>该代码将输出：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; undefinedJohn Doe</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第一个console.log打印未定义，因为我们从hero对象中提取方法，所以stoleSecretIdentity（）在_name属性不存在的全局上下文（即窗口对象）中被调用。</p>
<p>修复stoleSecretIdentity（）函数的一种方法如下：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var stoleSecretIdentity = hero.getSecretIdentity.bind(hero);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="25、创建一个函数，给定页面上的DOM元素，将访问元素本身及其所有后代（不仅仅是它的直接子元素）。对于每个访问的元素，函数应该将该元素传递给提供的回调函数。"><a href="#25、创建一个函数，给定页面上的DOM元素，将访问元素本身及其所有后代（不仅仅是它的直接子元素）。对于每个访问的元素，函数应该将该元素传递给提供的回调函数。" class="headerlink" title="25、创建一个函数，给定页面上的DOM元素，将访问元素本身及其所有后代（不仅仅是它的直接子元素）。对于每个访问的元素，函数应该将该元素传递给提供的回调函数。"></a><strong>25、创建一个函数，给定页面上的DOM元素，将访问元素本身及其所有后代（不仅仅是它的直接子元素）。对于每个访问的元素，函数应该将该元素传递给提供的回调函数。</strong></h3><p>该函数的参数应该是：</p>
<ul>
<li>一个 DOM 元素</li>
<li>一个回调函数（以DOM元素作为参数）</li>
</ul>
<p>访问树中的所有元素（DOM）是[经典的深度优先搜索算法]Depth-First-Search algorithm应用程序。以下是一个示例解决方案：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; function Traverse(p_element,p_callback) &#123;</span><br><span class="line">&gt;    p_callback(p_element);   </span><br><span class="line">&gt; var list = p_element.children;  </span><br><span class="line">&gt;  for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">&gt;        Traverse(list[i],p_callback);  </span><br><span class="line">&gt;  // recursive call</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="27、在JavaScript中测试您的这些知识：以下代码的输出是什么？"><a href="#27、在JavaScript中测试您的这些知识：以下代码的输出是什么？" class="headerlink" title="27、在JavaScript中测试您的这些知识：以下代码的输出是什么？"></a><strong>27、在JavaScript中测试您的这些知识：以下代码的输出是什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; var length = 10;function fn() &#123;   </span><br><span class="line">&gt;  console.log(this.length);</span><br><span class="line">&gt; &#125;var obj = &#123; </span><br><span class="line">&gt;   length: 5,  method: function(fn) &#123;</span><br><span class="line">&gt;     fn();    arguments[0]();</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; obj.method(fn, 1);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 102</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为什么不是10和5？</p>
<p>首先，由于fn作为函数方法的参数传递，函数fn的作用域（this）是窗口。 var length = 10;在窗口级别声明。它也可以作为window.length或length或this.length来访问（当这个===窗口时）。</p>
<p>方法绑定到Object obj，obj.method用参数fn和1调用。虽然方法只接受一个参数，但调用它时已经传递了两个参数;第一个是函数回调，其他只是一个数字。</p>
<p>当在内部方法中调用fn（）时，该函数在全局级别作为参数传递，this.length将有权访问在Object obj中定义的var length = 10（全局声明）而不是length = 5。</p>
<p>现在，我们知道我们可以使用arguments []数组访问JavaScript函数中的任意数量的参数。</p>
<p>因此arguments0只不过是调用fn（）。在fn里面，这个函数的作用域成为参数数组，并且记录参数[]的长度将返回2。</p>
<p>因此输出将如上所述。</p>
<p>### </p>
<h3 id="28、考虑下面的代码。输出是什么，为什么？"><a href="#28、考虑下面的代码。输出是什么，为什么？" class="headerlink" title="28、考虑下面的代码。输出是什么，为什么？"></a><strong>28、考虑下面的代码。输出是什么，为什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; (function () &#123;</span><br><span class="line">&gt;     try &#123;</span><br><span class="line">&gt;         throw new Error();</span><br><span class="line">&gt;     &#125; catch (x) &#123;</span><br><span class="line">&gt;         var x = 1, y = 2;</span><br><span class="line">&gt;         console.log(x);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     console.log(x);</span><br><span class="line">&gt;     console.log(y);&#125;)();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1undefined2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>var语句被挂起（没有它们的值初始化）到它所属的全局或函数作用域的顶部，即使它位于with或catch块内。但是，错误的标识符只在catch块内部可见。它相当于：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; (function () &#123;    var x, y; // outer and hoisted</span><br><span class="line">&gt;     try &#123;        throw new Error();</span><br><span class="line">&gt;     &#125; catch (x /* inner */) &#123;</span><br><span class="line">&gt;         x = 1; // inner x, not the outer one</span><br><span class="line">&gt;         y = 2; // there is only one y, which is in the outer scope</span><br><span class="line">&gt;         console.log(x /* inner */);</span><br><span class="line">&gt;     &#125;    console.log(x);    console.log(y);</span><br><span class="line">&gt; &#125;)();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="29、这段代码的输出是什么？"><a href="#29、这段代码的输出是什么？" class="headerlink" title="29、这段代码的输出是什么？"></a><strong>29、这段代码的输出是什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; var x = 21;</span><br><span class="line">&gt; var girl = function () &#123;    </span><br><span class="line">&gt; console.log(x);   </span><br><span class="line">&gt;  var x = 20;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; girl ();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>21，也不是20，结果是‘undefined’的</p>
<p>这是因为JavaScript初始化没有被挂起。</p>
<p>（为什么它不显示21的全局值？原因是当函数执行时，它检查是否存在本地x变量但尚未声明它，因此它不会查找全局变量。 ）</p>
<p>### </p>
<h3 id="30、你如何克隆一个对象？"><a href="#30、你如何克隆一个对象？" class="headerlink" title="30、你如何克隆一个对象？"></a><strong>30、你如何克隆一个对象？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var obj = &#123;a: 1 ,b: 2&#125;var objclone = Object.assign(&#123;&#125;,obj);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在objclone的值是{a：1，b：2}，但指向与obj不同的对象。</p>
<p>但请注意潜在的缺陷：Object.clone（）只会执行浅拷贝，而不是深拷贝。这意味着嵌套的对象不会被复制。他们仍然引用与原始相同的嵌套对象：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; let obj = &#123;    </span><br><span class="line">&gt; a: 1,    b: 2,    c: &#123;   </span><br><span class="line">&gt;      age: 30</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;      var objclone = Object.assign(&#123;&#125;,obj);</span><br><span class="line">&gt;      console.log(&apos;objclone: &apos;, objclone);obj.c.age = 45;console.log(&apos;After Change - obj: &apos;, obj);     </span><br><span class="line">&gt;          // 45 - This also changes</span><br><span class="line">&gt; console.log(&apos;After Change - objclone: &apos;, objclone);</span><br><span class="line">&gt;           // 45</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">&gt;   setTimeout(function() &#123;</span><br><span class="line">&gt;  console.log(i); &#125;, i * 1000 );</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="31、此代码将打印什么？"><a href="#31、此代码将打印什么？" class="headerlink" title="31、此代码将打印什么？"></a><strong>31、此代码将打印什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">&gt;     setTimeout(function() &#123; </span><br><span class="line">&gt; console.log(i); &#125;, i * 1000 );</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它会打印0 1 2 3 4，因为我们在这里使用let而不是var。变量i只能在for循环的块范围中看到。</p>
<h3 id="32、以下几行输出什么，为什么？"><a href="#32、以下几行输出什么，为什么？" class="headerlink" title="32、以下几行输出什么，为什么？"></a><strong>32、以下几行输出什么，为什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(1 &lt; 2 &lt; 3);</span><br><span class="line">&gt; console.log(3 &gt; 2 &gt; 1);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>第一条语句返回true，如预期的那样。</p>
<p>第二个返回false是因为引擎如何针对&lt;和&gt;的操作符关联性工作。它比较从左到右，所以3&gt; 2&gt; 1 JavaScript翻译为true&gt; 1. true具有值1，因此它比较1&gt; 1，这是错误的。</p>
<h3 id="33、如何在数组的开头添加元素？最后如何添加一个？"><a href="#33、如何在数组的开头添加元素？最后如何添加一个？" class="headerlink" title="33、如何在数组的开头添加元素？最后如何添加一个？"></a><strong>33、如何在数组的开头添加元素？最后如何添加一个？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; var myArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</span><br><span class="line">&gt; myArray.push(&apos;end&apos;);</span><br><span class="line">&gt; myArray.unshift(&apos;start&apos;);</span><br><span class="line">&gt; console.log(myArray); </span><br><span class="line">&gt; // [&quot;start&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;end&quot;]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用ES6，可以使用扩展运算符：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; myArray = [&apos;start&apos;, ...myArray];myArray = [...myArray, &apos;end&apos;];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>或者，简而言之：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; myArray = [&apos;start&apos;, ...myArray, &apos;end&apos;];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="34、想象一下你有这样的代码"><a href="#34、想象一下你有这样的代码" class="headerlink" title="34、想象一下你有这样的代码:"></a><strong>34、想象一下你有这样的代码:</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var a = [1, 2, 3];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>a）这会导致崩溃吗？</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; a[10] = 99;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>b）这个输出是什么？</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(a[6]);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>a）它不会崩溃。 JavaScript引擎将使阵列插槽3至9成为“空插槽”。</p>
<p>b）在这里，a [6]将输出未定义的值，但时隙仍为空，而不是未定义的。在某些情况下，这可能是一个重要的细微差别。例如，使用map（）时，map（）的输出中的空插槽将保持为空，但未定义的插槽将使用传递给它的函数重映射：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; var b = [undefined];</span><br><span class="line">&gt; b[2] = 1;console.log(b);           </span><br><span class="line">&gt;   // (3) [undefined, empty × 1, 1]</span><br><span class="line">&gt; console.log(b.map(e =&gt; 7));</span><br><span class="line">&gt;    // (3) [7,         empty × 1, 7]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>### </p>
<h3 id="35、typeof-undefined-typeof-NULL的值是什么？"><a href="#35、typeof-undefined-typeof-NULL的值是什么？" class="headerlink" title="35、typeof undefined == typeof NULL的值是什么？"></a><strong>35、typeof undefined == typeof NULL的值是什么？</strong></h3><p>该表达式将被评估为true，因为NULL将被视为任何其他未定义的变量。</p>
<blockquote>
<p>注意：JavaScript区分大小写，我们在这里使用NULL而不是null。</p>
</blockquote>
<p>### </p>
<h3 id="36、代码返回后会怎么样？"><a href="#36、代码返回后会怎么样？" class="headerlink" title="36、代码返回后会怎么样？"></a><strong>36、代码返回后会怎么样？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(typeof typeof 1);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>string</p>
</blockquote>
<p>typeof 1将返回“number”，typeof“number”将返回字符串。</p>
<h3 id="37、以下代码输出什么？为什么？"><a href="#37、以下代码输出什么？为什么？" class="headerlink" title="37、以下代码输出什么？为什么？"></a><strong>37、以下代码输出什么？为什么？</strong></h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; var b = 1;function outer()&#123;   </span><br><span class="line">&gt;     var b = 2</span><br><span class="line">&gt;     function inner()&#123;</span><br><span class="line">&gt;         b++;     </span><br><span class="line">&gt;        var b = 3;     </span><br><span class="line">&gt;           console.log(b)</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     inner();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; outer();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出到控制台将是“3”。</p>
<p>在这个例子中有三个闭包，每个都有它自己的var b声明。当调用变量时，将按照从本地到全局的顺序检查闭包，直到找到实例。由于内部闭包有自己的b变量，这就是输出。</p>
<p>此外，由于提升内部的代码将被解释如下：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; function inner () &#123;    </span><br><span class="line">&gt; var b; </span><br><span class="line">&gt; // b is undefined</span><br><span class="line">&gt;     b++; </span><br><span class="line">&gt; // b is NaN</span><br><span class="line">&gt;     b = 3;</span><br><span class="line">&gt;  // b is 3</span><br><span class="line">&gt;     console.log(b);</span><br><span class="line">&gt;   // output &quot;3&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/08/08/37个JavaScript基本面试问题和解答/">37个JavaScript基本面试问题和解答</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">李大玄</a></p>
        <p><span>发布时间:</span>2018-08-08, 16:39:05</p>
        <p><span>最后更新:</span>2018-08-09, 16:30:35</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/08/08/37个JavaScript基本面试问题和解答/" title="37个JavaScript基本面试问题和解答">http://yoursite.com/2018/08/08/37个JavaScript基本面试问题和解答/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/08/08/37个JavaScript基本面试问题和解答/　　作者: 李大玄" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/08/08/JS中this关键字详解/">
                    JS中this关键字详解
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/08/08/JavaScript垃圾回收机制/">
                    JavaScript垃圾回收机制
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、使用typeof-bar-“object”来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免？"><span class="toc-number">1.</span> <span class="toc-text">1、使用typeof bar ===“object”来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、下面的代码将输出到控制台的是什么，为什么？"><span class="toc-number">2.</span> <span class="toc-text">2、下面的代码将输出到控制台的是什么，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、下面的代码将输出到控制台的是什么？，为什么？"><span class="toc-number">3.</span> <span class="toc-text">3、下面的代码将输出到控制台的是什么？，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、在功能块中封装JavaScript源文件的全部内容的重要性和原因是什么？"><span class="toc-number">4.</span> <span class="toc-text">4、在功能块中封装JavaScript源文件的全部内容的重要性和原因是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、在JavaScript源文件的开头包含’use-strict’的意义和有什么好处？"><span class="toc-number">5.</span> <span class="toc-text">5、在JavaScript源文件的开头包含’use strict’的意义和有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、考虑下面的两个函数。他们都会返回同样的值吗？为什么或者为什么不？"><span class="toc-number">6.</span> <span class="toc-text">6、考虑下面的两个函数。他们都会返回同样的值吗？为什么或者为什么不？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、什么是NaN？它的类型是什么？如何可靠地测试一个值是否等于NaN？"><span class="toc-number">7.</span> <span class="toc-text">7、什么是NaN？它的类型是什么？如何可靠地测试一个值是否等于NaN？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、下面的代码输出什么？解释你的答案。"><span class="toc-number">8.</span> <span class="toc-text">8、下面的代码输出什么？解释你的答案。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、执行下面的代码时，按什么顺序将数字1-4记录到控制台？为什么？"><span class="toc-number">9.</span> <span class="toc-text">9、执行下面的代码时，按什么顺序将数字1-4记录到控制台？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是-palindrome-。"><span class="toc-number">10.</span> <span class="toc-text">10、编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是**palindrome**。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11、写一个sum方法，当使用下面的语法调用时它将正常工作。"><span class="toc-number">11.</span> <span class="toc-text">11、写一个sum方法，当使用下面的语法调用时它将正常工作。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12、考虑下面的代码片段"><span class="toc-number">12.</span> <span class="toc-text">12、考虑下面的代码片段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13、假设d是范围内的“空”对象："><span class="toc-number">13.</span> <span class="toc-text">13、假设d是范围内的“空”对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number">14.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14、下面的代码将输出到控制台，为什么？"><span class="toc-number">15.</span> <span class="toc-text">14、下面的代码将输出到控制台，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15、下面的代码将输出到控制台，为什么？"><span class="toc-number">16.</span> <span class="toc-text">15、下面的代码将输出到控制台，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16、如果数组列表太大，以下递归代码将导致堆栈溢出。你如何解决这个问题，仍然保留递归模式？"><span class="toc-number">17.</span> <span class="toc-text">16、如果数组列表太大，以下递归代码将导致堆栈溢出。你如何解决这个问题，仍然保留递归模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17、什么是JavaScript中的“闭包”？举一个例子。"><span class="toc-number">18.</span> <span class="toc-text">17、什么是JavaScript中的“闭包”？举一个例子。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18、以下代码的输出是什么："><span class="toc-number">19.</span> <span class="toc-text">18、以下代码的输出是什么：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19、以下几行代码输出到控制台？"><span class="toc-number">20.</span> <span class="toc-text">19、以下几行代码输出到控制台？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-、下面的代码执行时输出是什么？说明。"><span class="toc-number">21.</span> <span class="toc-text">20 、下面的代码执行时输出是什么？说明。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21、以下代码的输出是什么？解释你的答案。"><span class="toc-number">22.</span> <span class="toc-text">21、以下代码的输出是什么？解释你的答案。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22、以下代码将输出到控制台中"><span class="toc-number">23.</span> <span class="toc-text">22、以下代码将输出到控制台中.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-、考虑下面的代码片段。控制台的输出是什么，为什么？"><span class="toc-number">24.</span> <span class="toc-text">23 、考虑下面的代码片段。控制台的输出是什么，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24、以下代码将输出到控制台以及为什么"><span class="toc-number">25.</span> <span class="toc-text">24、以下代码将输出到控制台以及为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25、创建一个函数，给定页面上的DOM元素，将访问元素本身及其所有后代（不仅仅是它的直接子元素）。对于每个访问的元素，函数应该将该元素传递给提供的回调函数。"><span class="toc-number">26.</span> <span class="toc-text">25、创建一个函数，给定页面上的DOM元素，将访问元素本身及其所有后代（不仅仅是它的直接子元素）。对于每个访问的元素，函数应该将该元素传递给提供的回调函数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27、在JavaScript中测试您的这些知识：以下代码的输出是什么？"><span class="toc-number">27.</span> <span class="toc-text">27、在JavaScript中测试您的这些知识：以下代码的输出是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28、考虑下面的代码。输出是什么，为什么？"><span class="toc-number">28.</span> <span class="toc-text">28、考虑下面的代码。输出是什么，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29、这段代码的输出是什么？"><span class="toc-number">29.</span> <span class="toc-text">29、这段代码的输出是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30、你如何克隆一个对象？"><span class="toc-number">30.</span> <span class="toc-text">30、你如何克隆一个对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31、此代码将打印什么？"><span class="toc-number">31.</span> <span class="toc-text">31、此代码将打印什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32、以下几行输出什么，为什么？"><span class="toc-number">32.</span> <span class="toc-text">32、以下几行输出什么，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33、如何在数组的开头添加元素？最后如何添加一个？"><span class="toc-number">33.</span> <span class="toc-text">33、如何在数组的开头添加元素？最后如何添加一个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">34.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34、想象一下你有这样的代码"><span class="toc-number">35.</span> <span class="toc-text">34、想象一下你有这样的代码:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35、typeof-undefined-typeof-NULL的值是什么？"><span class="toc-number">36.</span> <span class="toc-text">35、typeof undefined == typeof NULL的值是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36、代码返回后会怎么样？"><span class="toc-number">37.</span> <span class="toc-text">36、代码返回后会怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37、以下代码输出什么？为什么？"><span class="toc-number">38.</span> <span class="toc-text">37、以下代码输出什么？为什么？</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"37个JavaScript基本面试问题和解答　| 李大玄的博客　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/08/08/JS中this关键字详解/" title="上一篇: JS中this关键字详解">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/08/08/JavaScript垃圾回收机制/" title="下一篇: JavaScript垃圾回收机制">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/css Sprites的优缺点/">精灵图的优缺点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/ECMAScript 6 let和const命令/">ECMAScript 6 let和const命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/HTML常见的兼容性问题/">html常见的兼容性问题？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/全选反选不选/">全选反选不选</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/axios插件的使用操作/">axios插件的使用操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/12/2018前端面试题/">2018年web前端经典面试题及答案</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/10/数组的方法/">数组的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/10/字符串的操作/">字符串的操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/JSONP的优缺点/">JSONP的优缺点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/JS中this关键字详解/">JS中this关键字详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/37个JavaScript基本面试问题和解答/">37个JavaScript基本面试问题和解答</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/JavaScript垃圾回收机制/">JavaScript垃圾回收机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/对于页面适配，你应该使用px还是rem/">对于页面适配，你应该使用px还是rem</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/移动端轮播图/">移动端轮播图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/封装移动端手势事件/">封装移动端手势事件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/前端面试题整理/">前端面试题整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/05/css中清除浮动/">css清除浮动</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/05/封装移动端的轻敲事件/">封装移动端的轻敲事件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/02/3D切割轮播图/">模板3D切割轮播图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/js中的函数进价/">js中的函数进价</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/函数中的继承/">函数中的继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/markdown基本语法/">markdown基本语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/H5新增的API/">模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/29/内置对象公式/">公式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/雪花飘落/">雪花飘落</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/数组去重的几种方法/">数组去重的几种方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/18/session和cookie的区别/">JSP中session与cookie的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/17/Include和require的区别/">include和require区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/17/jQuery版轮播图/">jQuery版轮播图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/js中filter的使用/">javascript中filter的用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/跨域请求/">跨域请求</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/封装$,get()方法/">$.get方法封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/09/NAN的定义与用法/">NaN的定义与用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/06/分享几个面试题/">几道面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/JS原生轮播图/">JS 原生轮播图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/如何创建私人Git/">如何创建私人Git</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/JavaScript基础/">JavaScript基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 李大玄
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>